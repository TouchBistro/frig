## Form
*Available as `Frig.form` in JSX and `Frig.dsl` in the Coffeescript DSL*

### Props

* **data (required)** - either a ReactLink or an object. This is used to populate the values of each field in the form. The data property is also used by inputs for type inference where a `type` property is not provided. If a ReactLink is provided the ReactLink will be updated with the user's inputs. In the Coffeescript DSL version the form is the last argument.
* **form (required)** - a function. The form callback is expected to generate the content of the form as either a single React component or array of components. The form callback receives an object `f` containing the Frig components needed to build a form (In the Coffeescript DSL these components are replaced with equivalent functions).
* **errors (optional)** - an array of strings. The list of errors supplied here can be rendered by the `f.errors` component.
* **onSubmit (optional)** - a function. Called after the submit button is clicked and all validations have passed. The DOM event is passed to the callback.

### Public Functions

These functions can be called on the frig form object (eg. using React refs).

* **validate()** - validates the form's inputs and renders all errors.
* **isValid()** - returns true if all of the form's inputs are in a valid state. Does not visibly render errors.
* **isModified()** - returns true if any of the form's inputs have been modified by the user (in other words `props.data` changes do not count).
* **

## f.input

Frig Inputs are your interface to any kind of form element that allow the user to edit their data.

For example `<f.input name="username"/>` will render a HTML input element by default however `<f.input name="friends" type="typeahead" multiple=true options=["Jane", "Joe"]/>` will render a typeahead multi-select.

An input receives a name and loads its value from the form's data (ie. `value = form.props.data[input.props.name]`). To specificy a type of form element to render you can either set its `props.type` or `props.component` or leave both blank and have the input guess its type based on the form data and its name (see *Type Inference*).

#### Props
* **name (required)** - a string. The key of the input's value in the form's `props.data`
* **type (optional)** - a string. The type of input. If a type is not provided it will be guessed based on the input's name and value (based on the form's data). the `f.input` is basically a wrapper for specific "themed inputs" (just normal react components defined by the Frig theme). See the *Available Input Types* section for a complete list of type values.
* **component (optional)** - a React Component. Overrides the themed input specified by the type with a specific React Component to provide the user interface implementation of the input.
* **errors (optional)** - an array of strings. These errors are appended to the errors generated by the input's validations.
* **options (optional)** - Sets the options for a `select` or `typeahead` type input. An array of one of the following:
    * `{value: OBJECT, label: STRING}`
    * `[LABEL_STRING, VALUE_OBJECT]`
    * `STRING`
* **className (optional)** - string. Custom class names for the input.
* **disabled (optional)** - boolean (default: false). If set to true will disable user input.
* **multiple (optional)** - boolean (default: false). If set to true will enable mutiple-selection (eg. for a select form election).
* **validate (optional)** - boolean (default: true). If set to false will prevent validations from running on this input.

**In addition some input types can have additional props specified. Please read the frigging_bootstrap source code for details.**

#### Available Input Types and their Themed Input Components

Each type identifies a React Component in the theme (eg. FriggingBootstrap) to use inside of the input as the user interface to that particular input. We call these component Themed Input Components to distinguish them from the Frig Input Component.

| Type            | Component              |
|---------------- | ---------------------- |
|"string"         | input[type=text]       |
|"password"       | input[type=password]   |
|"email"          | input[type=email]      |
|"url"            | input[type=url]        |
|"tel"            | input[type=tel]        |
|"boolean"        | input[type=checkbox]   |
|"text"           | text                   |
|"file"           | file[type=file]        |
|"float"          | input[type=number]     |
|"switch"         | switch                 |
|"time"           | timepicker             |
|"select"         | select                 |
|"typeahead"      | typeahead              |


#### Type Inference

If a `type` isn't specified then the input's type will be guessed based on the form data and its name according to the following rules:

1. If `multiple` or `options` is specified then the type will default to a `select`
2. If `form.props[input.props.name]` is an array then the type will default to a `select`
3. If the `name` ends in `"password"` then the type will default to a `password`
4. Otherwise the type is based on the `typeof` of the `form.props[input.props.name]`


## f.nestedFields

A Nested field takes a name (some key in the form's data) and produces one or more recursive (ie. nested) forms. Nested fields accomidate both "has one" (nested objects) and "has many" (nested arrays of objects) relationships in form data.

Calling validate/isValid/isModified on a parent form object will call it on all of it's nested fields and incorporate their values recursively.

#### Props
* **name (required)** - The key of the nested fields' data object (or array of data objects) in the form's `props.data`
* **form (required)** - a function. The form callback is expected to generate the content of the nested fields as either a single React component or array of components. The form callback receives an object `f` containing the Frig components needed to build a form (In the Coffeescript DSL these components are replaced with equivalent functions). A second integer `index` argument is added to nested field form callbacks since nested fields can be used on arrays of data.

#### Coffeescript DSL
* In the Coffeescript DSL version of `f.nestedFields` the function accepts two arguments. The first argument is the name and second is the form callback.

#### Examples
* JSX: `<f.nestedFields name="address" form=this.addressForm/>`
* Coffeescript `f.nestedFields "address", this.addressForm`

## f.submit

#### Props
* **title (optional)** - a string. The text of the submit button. This is the first argument of the coffeescript DSL version.

#### Examples
* JSX: `<f.submit title="Log In"/>`
* Coffeescript `f.submit("Log In")`


## f.errors

The errors component renders all the form-level errors in the form's `props.errors`.

#### Examples
* JSX: `<f.errors/>`
* Coffeescript `f.errors()`
